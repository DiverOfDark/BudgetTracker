using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using BudgetTracker.JsModel;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.EntityFrameworkCore.Internal;

namespace BudgetTracker.JsApiGenerator
{
    class Program
    {
        const string fileName = @"..\BudgetTracker.Client\src\generated-types.ts";

        static void Main(string[] args)
        {
            File.WriteAllText(fileName, @"// autogenerated
import './services/Rest';

");
            
            var types = typeof(Startup).Assembly.GetTypes();
            var exportableTypes = types.Where(v => v.GetCustomAttribute<ExportJsModelAttribute>() != null).ToList();
            foreach (var type in exportableTypes)
            {
                GenerateType(type, exportableTypes);
            }

            var controllers = types.Where(v => typeof(Controller).IsAssignableFrom(v)).ToList();
            foreach (var controller in controllers)
            {
                GenerateController(controller, exportableTypes);
            }
        }

        private static void GenerateController(Type type, IEnumerable<Type> knownTypes)
        {
            var controllerName = type.Name;

            var methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
                .Where(v => !typeof(IActionResult).IsAssignableFrom(ExpandType(v.ReturnType)))
                .GroupBy(v => v.Name)
                .Select(v => v.OrderByDescending(s => s.GetParameters().Length).First())
                .ToList();

            if (!methods.Any())
                return;
            
            using (var fileWrite = File.AppendText(fileName))
            {
                fileWrite.Write($"export class {type.Name} {{\n");

                foreach (var method in methods)
                {
                    var jsMethod = method.GetCustomAttribute<CacheableRestAttribute>() == null
                        ? "query"
                        : "cachedQuery";
                    
                    fileWrite.Write($"    static async {GetMethodSignature(method)}: Promise<{GetTypescriptType(method.ReturnType, knownTypes)}> {{ return window.rest.{jsMethod}({GetMethodQuery(method, controllerName)}); }};\n");
                }
                
                fileWrite.Write("}\n\n");
            }
        }
        
        private static string GetMethodSignature(MethodInfo method)
        {
            var args = method.GetParameters().Select(v => FilterKeywords(v.Name) + ": " + GetTypescriptType(v.ParameterType, Enumerable.Empty<Type>()))
                .Join(", ");
            return $"{method.Name}({args})";
        }

        private static string FilterKeywords(string argName)
        {
            switch (argName)
            {   
                case "function":
                    return "function2";
                default:
                    return argName;
            }
        }

        private static string GetMethodQuery(MethodInfo method, string controllerName)
        {
            var endpoint = $"`/{controllerName}/{method.Name}";
            var param = method.GetParameters();
            if (param.Length > 0)
            {
                endpoint += "?";
                endpoint += param.Select(v => v.Name + "=" + "` + " + FilterKeywords(v.Name) + " + `").Join("&");
            }
            return endpoint + "`";
        }

        private static void GenerateType(Type type, IEnumerable<Type> knownTypes)
        {
            Console.WriteLine($"Exporting {type.Name}...");
            using (var fileWrite = File.AppendText(fileName))
            {
                fileWrite.Write($"export interface {type.Name} {{\n");

                foreach (var p in type.GetProperties())
                {
                    try
                    {
                        var formattableString = $"   {p.Name}: {GetTypescriptType(p.PropertyType, knownTypes)};";
                        fileWrite.WriteLine(formattableString);
                    }
                    catch(Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                }
                
                fileWrite.Write("}\n\n");
                
            }
        }

        private static Type ExpandType(Type type)
        {
            if (typeof(Task).IsAssignableFrom(type) && type.IsGenericType)
            {
                return type.GetGenericArguments()[0];
            }

            if (typeof(Nullable).IsAssignableFrom(type) && type.IsGenericType)
            {
                return type.GetGenericArguments()[0];
            }

            return type;
        } 

        private static string GetTypescriptType(Type type, IEnumerable<Type> knownTypes)
        {
            type = ExpandType(type);
            
            if (knownTypes.Contains(type))
                return type.Name;
            
            if (type == typeof(String) || type == typeof(Guid) || type.IsEnum)
                return "string";
            if (type == typeof(DateTime))
                return "Date";
            if (type == typeof(int))
                return "number";
            if (type == typeof(double))
                return "number";
            if (type == typeof(bool))
                return "boolean";
            if (type == typeof(IEnumerable<String>))
                return "string[]";

            var oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.DarkRed;
            Console.WriteLine("Unsupported type " + type.FullName);
            Console.ForegroundColor = oldColor;
            return "any";
        }
    }
}