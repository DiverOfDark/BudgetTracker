using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using BudgetTracker.JsModel;
using BudgetTracker.JsModel.Attributes;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore.Internal;

namespace BudgetTracker.JsApiGenerator
{
    class Program
    {
        private static string _fileName;

        static void Main(string[] args)
        {
            _fileName = string.Join(Path.DirectorySeparatorChar,
                new[] {@"..", "BudgetTracker.Client", "src", "generated-types.ts"});

            _fileName = Path.GetFullPath(_fileName);
            Console.WriteLine("Generating rest client to {0}", _fileName);
            
            File.WriteAllText(_fileName, @"// autogenerated
import './services/Rest';

");
            
            var types = typeof(Startup).Assembly.GetTypes();
            var exportableTypes = types.Where(v => v.GetCustomAttribute<ExportJsModelAttribute>() != null).ToList();
            foreach (var type in exportableTypes)
            {
                GenerateType(type, exportableTypes);
            }

            var controllers = types.Where(v => typeof(Controller).IsAssignableFrom(v) && v.GetCustomAttribute<HideFromRestAttribute>() == null).ToList();
            foreach (var controller in controllers)
            {
                GenerateController(controller, exportableTypes);
            }
        }

        private static void GenerateController(Type type, IEnumerable<Type> knownTypes)
        {
            var controllerName = type.Name;
            if (controllerName.EndsWith("Controller"))
            {
                controllerName = controllerName.Substring(0, controllerName.IndexOf("Controller"));
            }

            var whiteList = new[] {typeof(OkResult)};

            var methodInfos = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
                .Where(v => v.GetCustomAttribute<HideFromRestAttribute>() == null)
                .ToList();
            
            var methods = methodInfos
                .Where(v => !typeof(IActionResult).IsAssignableFrom(ExpandType(v.ReturnType)) || whiteList.Contains(v.ReturnType))
                .GroupBy(v => v.Name)
                .Select(v => v.OrderByDescending(s => s.GetParameters().Length).First())
                .ToList();
            
            var navigations = methodInfos
                .Where(v => typeof(IActionResult).IsAssignableFrom(ExpandType(v.ReturnType)) || whiteList.Contains(v.ReturnType))
                .Where(v => v.GetParameters().Length == 0)
                .ToList(); 

            if (!methods.Any() && !navigations.Any())
                return;
            
            using (var fileWrite = File.AppendText(_fileName))
            {
                fileWrite.Write($"export class {type.Name} {{\n");

                foreach (var method in methods)
                {
                    var jsMethod = method.GetCustomAttribute<CacheableRestAttribute>() == null
                        ? "query"
                        : "cachedQuery";

                    var httpMethod = "\"GET\"";

                    if (method.GetCustomAttribute<HttpGetAttribute>() != null)
                    {
                        httpMethod = "\"GET\"";
                    }

                    if (method.GetCustomAttribute<HttpPostAttribute>() != null)
                    {
                        httpMethod = "\"POST\"";
                    }

                    bool hasResponse = GetTypescriptType(method.ReturnType, knownTypes) != "void";

                    fileWrite.WriteLine($"    static async {GetMethodSignature(method)}: Promise<{GetTypescriptType(method.ReturnType, knownTypes)}> {{ ");
                    fileWrite.WriteLine($"      return window.rest.{jsMethod}({GetMethodQuery(method, controllerName)}, {httpMethod}, {hasResponse.ToString().ToLower()}, {ShouldDeserialize(method.ReturnType).ToString().ToLower()}); ");
                    fileWrite.WriteLine( "    };");
                }

                if (navigations.Any() && methods.Any())
                {
                    fileWrite.WriteLine();
                }
                
                foreach (var navigation in navigations)
                {
                    fileWrite.WriteLine($"    static {CamelCase(FilterKeywords(navigation.Name))} = `/{controllerName}/{navigation.Name}`");
                }

                fileWrite.Write("}\n\n");
            }
        }

        private static bool ShouldDeserialize(Type type)
        {
            type = ExpandType(type);
            return !type.IsPrimitive && type != typeof(string);
        }
        
        private static string GetMethodSignature(MethodInfo method)
        {
            var args = method.GetParameters().Select(v => FilterKeywords(v.Name) + ": " + GetTypescriptType(v.ParameterType))
                .Join(", ");
            return $"{CamelCase(method.Name)}({args})";
        }

        private static string FilterKeywords(string argName)
        {
            switch (argName)
            {   
                case "function":
                    return "function2";
                default:
                    return argName;
            }
        }

        private static string GetMethodQuery(MethodInfo method, string controllerName)
        {
            var endpoint = $"`/{controllerName}/{method.Name}";
            var param = method.GetParameters();
            if (param.Length > 0)
            {
                endpoint += "?";
                endpoint += param.Select(v =>
                {
                    var value = GetTypescriptType(v.ParameterType) == "string" ? "encodeURIComponent(" + FilterKeywords(v.Name) + ")" : FilterKeywords(v.Name); 
                    return v.Name + "=" + "` + " + value + " + `";
                }).Join("&");
            }
            
            endpoint +="`";

            if (endpoint.EndsWith(" + ``"))
            {
                endpoint = endpoint.Substring(0, endpoint.LastIndexOf(" + ``"));
            }
            
            return endpoint;
        }

        private static void GenerateType(Type type, IEnumerable<Type> knownTypes)
        {
            Console.WriteLine($"Exporting {type.Name}...");
            using (var fileWrite = File.AppendText(_fileName))
            {
                fileWrite.Write($"export interface {type.Name} {{\n");

                foreach (var p in type.GetProperties())
                {
                    try
                    {
                        var formattableString = $"   {CamelCase(p.Name)}: {GetTypescriptType(p.PropertyType, knownTypes)};";
                        fileWrite.WriteLine(formattableString);
                    }
                    catch(Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                }
                
                fileWrite.Write("}\n\n");
                
            }
        }

        private static string CamelCase(string pName)
        {
            var sb = new StringBuilder(pName);
            sb[0] = sb[0].ToString().ToLower()[0];
            return sb.ToString();
        }

        private static Type ExpandType(Type type)
        {
            if (typeof(Task).IsAssignableFrom(type) && type.IsGenericType)
            {
                return type.GetGenericArguments()[0];
            }

            if (typeof(Nullable).IsAssignableFrom(type) && type.IsGenericType)
            {
                return type.GetGenericArguments()[0];
            }

            return type;
        } 

        private static string GetTypescriptType(Type type, IEnumerable<Type> knownTypes = null, [CallerLineNumber] int ln = 0, [CallerMemberName] string who = null)
        {
            type = ExpandType(type);
            
            bool array = false;
            if (typeof(IEnumerable).IsAssignableFrom(type) && type != typeof(string))
            {
                type = type.GetGenericArguments()[0];
                array = true;
            }

            string result = "";
            
            if (knownTypes?.Contains(type) == true)
                result = type.Name;
            else if (type == typeof(String) || type == typeof(Guid) || type.IsEnum)
                result = "string";
            else if (type == typeof(int))
                result = "number";
            else if (type == typeof(double))
                result = "number";
            else if (type == typeof(bool))
                result = "boolean";
            else if (type == typeof(DateTime))
                result = "string";
            else if (type == typeof(OkResult))
            {
                result = "void";
            } else {

                var oldColor = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.DarkRed;
                Console.Error.WriteLine($"Unsupported type {type.FullName} at {who}:{ln}");
                Console.ForegroundColor = oldColor;
                result = "any";
            }

            if (array)
            {
                result += "[]";
            }

            return result;

        }
    }
}