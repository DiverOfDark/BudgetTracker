using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.Linq;
using System.Runtime.CompilerServices;
using BudgetTracker.Model;
using BudgetTracker.Scrapers;
using Hangfire;
using Microsoft.Extensions.Logging;

namespace BudgetTracker.Services
{
    public class ScrapeService
    {
        private readonly ObjectRepository _objectRepository;
        private readonly ILogger<ScrapeService> _logger;
        private readonly List<GenericScraper> _scrapers;
        private readonly Chrome _chrome;

        public ScrapeService(Chrome chrome, ObjectRepository objectRepository, IEnumerable<GenericScraper> scrapers, ILogger<ScrapeService> logger)
        {
            _objectRepository = objectRepository;
            _logger = logger;
            _chrome = chrome;

            _scrapers = scrapers.ToList();
        }

        public void RegisterJobs(string interval)
        {
            foreach (var item in _scrapers)
            {
                var name = item.ProviderName;
                RecurringJob.AddOrUpdate<ScrapeService>($"{name} / State", x=>x.ScrapeCurrentState(name), interval);
                RecurringJob.AddOrUpdate<ScrapeService>($"{name} / Transactions", x=>x.ScrapeStatements(name), interval);
            }
        }

        [AutomaticRetry(Attempts = 3)]
        public void ScrapeStatements(string name) => ScrapeImpl(name, ScrapeStatementsImpl);

        [AutomaticRetry(Attempts = 3)]
        public void ScrapeCurrentState(string name) => ScrapeImpl(name, ScrapeCurrentStateImpl);

        public void ScrapeImpl(String name, Action<GenericScraper, ScraperConfigurationModel> action, [CallerMemberName] string caller = null)
        {
            if (!Startup.IsProduction)
                return;
            
            var scrapeConfig = _objectRepository.Set<ScraperConfigurationModel>().FirstOrDefault(v=>v.ScraperName == name);
            var scraper = _scrapers.FirstOrDefault(v => v.ProviderName == name);
            
            if (scrapeConfig == null || scraper == null)
            {
                _logger.LogInformation($"Not enabled scraper {name}");
                return;
            }

            lock (_chrome)
            {
                _chrome.Reset();

                try
                {
                    _logger.LogInformation($"Scraping {name} {caller}");
                    action(scraper, scrapeConfig);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"Failed to get state for {scraper.ProviderName}...");
                    throw;
                }
                finally
                {
                    _chrome.Reset();
                }
            }

            // default strategy - generated money statements from diff between states.
            foreach (var column in _objectRepository.Set<MoneyColumnMetadataModel>().Where(v => v.AutogenerateStatements))
            {
                var payments = _objectRepository.Set<PaymentModel>()
                    .Where(v => v.Column == column)
                    .ToList();

                var models = _objectRepository.Set<MoneyStateModel>()
                    .Where(v => v.Provider == column.Provider && v.AccountName == column.AccountName)
                    .OrderBy(v => v.When)
                    .ToList();

                if (models.Any())
                {
                    var emptyModel = new MoneyStateModel
                    {
                        Amount = 0,
                        Ccy = models.First().Ccy,
                        AccountName = models.First().AccountName,
                        Provider = models.First().Provider,
                        When = models.First().When.AddDays(-1)
                    };
                    models.Insert(0, emptyModel);

                    models.Aggregate((a, b) =>
                    {
                        var delta = b.Amount - a.Amount;

                        var matchingPayments = payments
                            .Where(v => v.Column == column && v.When >= a.When && v.When <= b.When).ToList();

                        delta -= matchingPayments.Sum(v => v.Amount);

                        delta = Math.Round(delta * 100, MidpointRounding.AwayFromZero) / 100;

                        if (Math.Abs(delta) >= 0.01)
                        {
                            var when = a.When + (b.When - a.When) / 2;
                            var kind = delta > 0 ? PaymentKind.Income : PaymentKind.Expense;

                            var paymentModel = payments.FirstOrDefault(v =>
                                v.Column == column && v.When >= a.When && v.When <= b.When && v.Autogenerated);

                            if (paymentModel == null)
                            {
                                paymentModel = new PaymentModel(when,
                                    "Коррекция баланса " + column.Provider + " " + column.AccountName,
                                    delta, kind, a.Ccy, "N/A-" + DateTime.Now.Ticks, column);

                                _objectRepository.Add(paymentModel);
                            }
                            else
                            {
                                paymentModel.Amount += delta;
                            }

                            paymentModel.Autogenerated = true;
                        }

                        return b;
                    });
                }
            }

            foreach(var item in _objectRepository.Set<MoneyStateModel>().GroupBy(v => v.Provider, v => v.AccountName))
            foreach (var sub in item.Distinct())
            {
                var existing = _objectRepository.Set<MoneyColumnMetadataModel>()
                    .FirstOrDefault(v => v.Provider == item.Key && v.AccountName == sub);

                if (existing == null)
                {
                    existing = new MoneyColumnMetadataModel(item.Key, sub)
                    {
                        UserFriendlyName = sub
                    };
                    _objectRepository.Add(existing);
                }
            }
        }

        private void ScrapeStatementsImpl(GenericScraper scraper, ScraperConfigurationModel scraperConfig)
        {
            var minDates = new[]
            {
                _objectRepository.Set<PaymentModel>()
                    .Where(v => v.Column?.Provider == scraper.ProviderName)
                    .OrderByDescending(v => v.When)
                    .FirstOrDefault()?.When,
                _objectRepository.Set<MoneyStateModel>().OrderBy(v => v.When)
                    .FirstOrDefault()?.When,
                _objectRepository.Set<PaymentModel>().OrderBy(v => v.When)
                    .FirstOrDefault()?.When
            };
            
            var lastPayment = minDates.Where(v => v != null).OrderBy(v => v).FirstOrDefault() ??
                              DateTime.MinValue;

            var scrapingSince = lastPayment.AddDays(-21);

            if (scraperConfig.LastSuccessfulStatementScraping != default)
                lastPayment = scraperConfig.LastSuccessfulStatementScraping;

            // Let's not scrape statements too often - it's hard
            if (lastPayment.AddHours(24) < DateTime.Now)
            {
                _logger.LogInformation(
                    $"Scraping statement for {scraper.ProviderName} since {scrapingSince}...");

                var statements = scraper.ScrapeStatement(scraperConfig, _chrome, scrapingSince)
                    .Where(v => v != null)
                    .ToList();

                _logger.LogInformation($"Got statement of {statements.Count} items...");

                if (statements.Count == 0)
                {
                    _logger.LogWarning("Suspicious statement count. For the sake of not deleting existing statements - not doing anything for now...");
                    return;
                }
                
                var excessiveStatements = _objectRepository.Set<PaymentModel>()
                    .Where(v =>
                        v.When > scrapingSince
                        && v.Column?.Provider == scraper.ProviderName
                        && !string.IsNullOrEmpty(v.StatementReference))
                    .ToList();

                var gotStatementReferences = statements.Select(v => v.StatementReference).Where(v => v != null)
                    .Distinct().ToHashSet();
                
                // Need to reimport changes done to this item from bank statement. i.e., if user edited statement which was HOLD - now there can be another statement about the same transaction with other reference
                foreach (var item in excessiveStatements.Where(v=>v.UserEdited && !gotStatementReferences.Contains(v.StatementReference)))
                {
                    item.StatementReference = null; 
                }
                
                foreach (var s in statements)
                {
                    var existingItem = 
                        excessiveStatements.FirstOrDefault(v => v.StatementReference == s.StatementReference)
                        ?? _objectRepository.Set<PaymentModel>().OrderBy(v => v.When)
                        .FirstOrDefault(v =>
                            Math.Abs((v.When.Date - s.When.Date).TotalDays) <= 4 &&
                            Math.Abs(v.Amount - s.Amount) < 0.01 &&
                            v.Ccy == s.Ccy &&
                            v.StatementReference == null);
                        

                    if (existingItem == null)
                    {
                        _objectRepository.Add(s);
                    }
                    else
                    {
                        excessiveStatements.Remove(existingItem);
                        
                        if (existingItem.Column == null)
                        {
                            existingItem.Column = _objectRepository.Set<MoneyColumnMetadataModel>()
                                .FirstOrDefault(v => v.Id == s.ColumnId);
                        }

                        if (existingItem.StatementReference == null)
                        {
                            existingItem.StatementReference = s.StatementReference;
                        }
                    }
                }

                _objectRepository.RemoveRange(excessiveStatements);

                if (statements.Any())
                {
                    scraperConfig.LastSuccessfulStatementScraping = DateTime.Now;
                }
            }
        }

        private void ScrapeCurrentStateImpl(GenericScraper scraper, ScraperConfigurationModel scraperConfig)
        {
            var currentState = _objectRepository.Set<MoneyStateModel>();

            var accountCount = currentState.Where(s =>
                    s.Provider == scraper.ProviderName && s.When.Date == DateTime.UtcNow.Date.AddDays(-1))
                .Select(s => s.AccountName).Distinct()
                .ToList();

            var todayState = currentState.Where(s =>
                    s.Provider == scraper.ProviderName && s.When.Date == DateTime.UtcNow.Date)
                .Select(s => s.AccountName).Distinct()
                .ToList();

            var toScrape = accountCount.Count == 0 || accountCount.Except(todayState).Any();

            if (toScrape)
            {
                _logger.LogInformation("No cached items, scraping...");

                var items = scraper.Scrape(scraperConfig, _chrome);

                _logger.LogInformation($"Found {items.Count()} items, indexing...");

                foreach (var item in items)
                {
                    _logger.LogInformation(
                        $" - {item.Provider} / {item.AccountName}: {item.Amount} ({item.Ccy})");
                    if (!string.IsNullOrWhiteSpace(item.Provider))
                    {
                        if (todayState.Contains(item.AccountName))
                            continue;

                        _objectRepository.Add(item);
                    }
                }

                scraperConfig.LastSuccessfulBalanceScraping = DateTime.Now;
                _logger.LogInformation("Indexed...");
            }
            else
            {
                _logger.LogInformation("For today there are already scraped items, continuing...");
            }
        }
    }
}